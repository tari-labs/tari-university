# Elliptic curves 101

This is very brief overview. There are better, and more complete introductions out there

* [ECC - a gentle introduction](http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/)
* [Digital Signatures](http://blog.oleganza.com/post/162861219668/eli5-how-digital-signatures-actually-work)
* [EdDSA standard](https://tools.ietf.org/html/rfc8032)

Note: Disclaimer. This is a rough guide for engineers wanting to get their hands wet with the nuts and bolts
of the cryptographic math behind blockchain security. Therefore I may be loosy goosy with some terminology 
and most of the concepts oversimplified, so excuse that. However, if there are any _egregious_ errors in this 
presentation, please [open an issue](https://github.com/tari-labs/tari-university/issues) on github.

---

# Elliptic Curves

$$ y^2 = x^3 + ax + b \mod p$$

* Described by this function
* But _x, y_ are integers
* And _x, y_ are between 0 and some prime number _p_

![Some elliptic curves](http://andrea.corbellini.name/images/curves.png)

Note: You can forget about all this technical detail. It's just included here for completeness.

---

# The key properties

* Addition (and multiplication by a scalar) is 'easy'
* Division (udoing the multiplication) is 'hard'

---

### Addition

@div[left-25]
![Addition](http://andrea.corbellini.name/images/point-addition.png)
@divend

@div[right-75]
<ul>
<li>Geometrically, $ P + Q + R = 0 $ if _P, Q, R_ all lie on the same "line" (mod _p_).
<li>Thus addition looks like: $ P + Q = -R $.
<li>_-R_ is R reflected around the line $ y = p / 2 $
</ul>

<p>
$ P + P $ has no geometric construction, but is analogous to tangent on the continuous curve 
(and the math works out the same - mod _p_)
</p>
@divend

---

# Scalar Multiplication

Define scalar multiplication as 

$$ nP = \underbrace{P + P + ... + P}_{n\text{ times}} $$

This can be calculated in $O(\log n)$ time, using the [double and add](http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#double-and-add)
algorithm. 

---

# Multiplication properties

These elliptic curves have the associative property:

$$ nP + mP = (n+m)P $$

but they are also _cyclic_, meaning for some value _n_, the results of the multiplication start repeating:

$$ kP = (k \mod n)P $$

* _P_ is called the base point or _generator_ of the curve.
* _n_ is the order of the cyclic subgroup of the curve generated by _P_.
* In ECC, _P_ is chosen so that _n_ is large

---

# Discrete logarithm problem

If we know _P_ and _Q_, and $ Q = kP \mod p $, can we easily find _k_?

i.e. $ k = Q/P $ 

* No known 'easy' algorithm (i.e. runs in polynomial time)
* need to do divide by trial and error (choose _k_, check, repeat)
* for large _k_, this takes too long to be feasible

### This is the basis of all ECC cryptography

note: Now that the abstract algebra stuff is largely out of the way, we can do some cryptography!

---

# Rules of cryptography (mod 3)

1. Never roll your own crypto
1. Never roll your own crypto
1. Don't. Roll. Your. Own. Crypto.

[because](http://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa#random-curves)
 [you will shoot yourself in the foot](https://medium.com/@neha/cryptographic-vulnerabilities-in-iota-9a6a9ddc4367)
 
### Exceptions: 
* `null`

---

# Elliptic Curve Cryptography (ECC)

* *Private key* a random integer $ d \in [1, n-1] $ with _n_ the order of the sub-group.
* *Public key* $ P = kG $, where _G_ is base point, or generator of the group

note: This should make sense now based on all the preliminary discussion. _k_ is kept secret, _kG_ is relatively 
easy to calculate, giving you a public key, but finding _k_ from _kG_ involves solving the discrete logarithm problem.

---

# Encryption with Elliptic Curve Diffie-Hellman (ECDH)

DH is a method for two parties to _securely exchange keys_.

| Alice              | Bob             
---------------------|------------------
| Create key pair $P_a = k_a.G$     | Create key pair $P_b = k_b.G$
| Sends Bob $P_a$                   | Sends Alice $P_b$
| Calc $P_s = k_a.H_b = k_a.k_b.G $ | Calc $ P_s = k_b.H_a = k_a.k_b.G $ 

$P_s$ is a shared secret than an eavesdropper has no practical hope of figuring out.

note: 
* When creating their keys, Alice and Bob use the same curve parameters: same curve, _G_ etc.
* When they exchange public keys, it can be over an insecure channel 

---

# Signing and verifying messages

Alice wants to **sign** a message, _m_, that Bob (or anyone else) can verify with her public key, $P_a$.

+++

# EdDSA algorithm

## Signing

1. Alice has her public and private keys $ P_a = k_aG $
1. Calculate a temporary key from random nonce _j_: $ R = rG $ 
1. Calc $ e = \text{Hash}(R || m)$
1. Calc $ s = r + ek_a $

Send _m_, _R_ and _s_ to Bob

note: This is a simplified algorithm. There are a few details ommitted, 
like always using modular arithmetic at limits on the choice of nonce.

+++

# EdDSA Verification

Bob has _s_, _R_, _m_, and $P_a$.

He doesn't know $k_a$ or _r_.

$$ s.G = (r + ek_a)G
       = rG + ek_aG
       = R + eP_a
$$

So Bob calculates _s.G_ and e, and compares it to $ R+ eP_a $.
If they match, he knows that Alice signed the message.





  




 


